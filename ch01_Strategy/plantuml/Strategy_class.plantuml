@startuml Strategy Pattern

package "客户"{
class Duck
{
    - FlyBehavior* m_flyBehavior
    - QuackBehavior* m_quackBehavior
    --
    + 
    + void display()
    + void performFly()
    + void performQuack()
    + void setFlyBehavior()
    + void setQuackBehavior()
    // 鸭子的其他行为...
}
note left of Duck::m_flyBehavior
把Duck容易改变的行为封装到对应的Behavior接口中，
委托对应的接口去完成不同的行为
end note

note left of Duck::performFly
在perform方法中委托接口的fly(), quack()方法
针对fly(),quack()接口编程，运行时动态绑定具体的实现类

end note

class MallarDuck extends Duck{
    +void display()
}
class RedheadDuck extends Duck{
    +void display()
}
class RubberDuck extends Duck{
    +void display()
}
class DecoyDuck extends Duck{
    +void display()
}
}
package "封装飞行行为" {
Duck -->FlyBehavior: has
interface FlyBehavior{
    + virtual void fly() = 0
}


class FlyWithWings implements FlyBehavior{
    void fly()
}
class FlyNoway implements FlyBehavior{
    void fly()
}
class FlynewWay implements FlyBehavior{
    void fly()
}
}

package "封装呱呱叫行为"{
Duck -->QuackBehavior: has

interface QuackBehavior{
    + virtual void quack() = 0
}
class SimpleQuack implements QuackBehavior{
    + void quack() \n{// 实现SimpleQuack}
}
class Mute implements QuackBehavior{
    + void quack() \n{// 实现Mute, do nothing.}
}
class NewQuack implements QuackBehavior{
    + void quack() \n{// 新增的Quack行为.}
}
}
@enduml

