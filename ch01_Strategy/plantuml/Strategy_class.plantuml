@startuml Strategy Pattern

package "Client"{
Abstract class Duck
{
    - FlyBehavior* m_flyBehavior
    - QuackBehavior* m_quackBehavior
    --
    + virtual void display() = 0
    + void performFly()
    + void performQuack()
    + void setFlyBehavior()
    + void setQuackBehavior()
    // other behavior of Duck...
}
note left of Duck::m_flyBehavior
把Duck容易改变的行为封装到对应的Behavior接口中，
委托对应的接口去完成不同的行为
end note

note left of Duck::performFly
m_flyBehavior->fly();  
针对接口编程，运行时动态绑定具体的实现类
end note

note left of Duck::performQuack
m_QuackBehavior->quack();  
针对接口编程，运行时动态绑定具体的实现类
end note

class MallarDuck extends Duck{
    +void display()
}

class RubberDuck extends Duck{
    +void display()
}
class DecoyDuck extends Duck{
    +void display()
}
}
package "Delegate flight behavior to <color:blue><Interface>FlyBehavoior" {
Duck -->FlyBehavior: knows(depend on)
interface FlyBehavior{
    + virtual void fly() = 0
}


class FlyWithWings implements FlyBehavior{
    void fly()
}
class FlyNoway implements FlyBehavior{
    void fly()
}
class FlynewWay implements FlyBehavior{
    void fly()
}
}

package "Delegate quack behavior to <color:blue><Interface>QuackBehavoior"{
Duck -->QuackBehavior: knows(depend on)

interface QuackBehavior{
    + virtual void quack() = 0
}
class SimpleQuack implements QuackBehavior{
    + void quack()
}
class Mute implements QuackBehavior{
    + void quack()
}
class NewQuack implements QuackBehavior{
    + void quack()
}
}
@enduml

