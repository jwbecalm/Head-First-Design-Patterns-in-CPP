@startuml Strategy Pattern

package "Client"{
class Duck
{
    - FlyBehavior* m_flyBehavior
    - QuackBehavior* m_quackBehavior
    --
    + void display()
    + void performFly()
    + void performQuack()
    + void setFlyBehavior()
    + void setQuackBehavior()
    // other behavior of Duck...
}
' note left of Duck::m_flyBehavior
' 把Duck容易改变的行为封装到对应的Behavior接口中，
' 委托对应的接口去完成不同的行为
' end note

' note left of Duck::performFly
' 在perform方法中委托接口的fly(), quack()方法
' 针对fly(),quack()接口编程，运行时动态绑定具体的实现类
' end note

class MallarDuck extends Duck{
    +void display()
}

class RubberDuck extends Duck{
    +void display()
}
class DecoyDuck extends Duck{
    +void display()
}
}
package "Delegate flight behavior to <color:blue><Interface>FlyBehavoior" {
Duck -->FlyBehavior: has
interface FlyBehavior{
    + virtual void fly() = 0
}


class FlyWithWings implements FlyBehavior{
    void fly()
}
class FlyNoway implements FlyBehavior{
    void fly()
}
class FlynewWay implements FlyBehavior{
    void fly()
}
}

package "Delegate quack behavior to <color:blue><Interface>QuackBehavoior"{
Duck -->QuackBehavior: has

interface QuackBehavior{
    + virtual void quack() = 0
}
class SimpleQuack implements QuackBehavior{
    + void quack()
}
class Mute implements QuackBehavior{
    + void quack()
}
class NewQuack implements QuackBehavior{
    + void quack()
}
}
@enduml

