@startuml Decorator Pattern

abstract Beverage{
    # string m_description 
    + Beverage(){m_description = "unknown"}
    + virtual string getDescription() {return m_description}
    + virtual double cost() = 0
}
note "Decorators have the same supertype as the objects they decorate\nSo both concreate decorator and component inherite from Beverage to have the same type." as N3

Interface AddsOnDecorator{
    + virtual string getDescription() = 0
    + virtual double cost() = 0
}


Beverage <|-- AddsOnDecorator
Beverage <-- AddsOnDecorator
package "Concrete Component"{
class Espresso  {
    + Espresso(){m_description = "Esresso"}
    + double cost()
}
note left of Espresso::cost()
0.98
end note
class Decaf {
    + Decaf(){m_description = "Decaf"}
    + double cost()
}
note left of Decaf::cost()
1.99
end note
note "*Each component can be used on its own, or wrapped by a decorator\n*Reuse the member m_description\n*Inherit the getDescription()\n from Beverage" as N1
Decaf .. N1
Espresso .. N1
}

Beverage <|-- Espresso
Beverage <|-- Decaf
package "Concrete Decorator"{
note "Each concrete decorator\n has a Beverage member to decorate(wrap)" as N2

class MilkDecorator extends AddsOnDecorator{
    - Beverage* m_beverage
    + MilkDecorator(Beverage* beverage):m_beverage(beverage){}
    + double cost()
    + string getDescription()
}

class MochaDecorator extends AddsOnDecorator{
    - Beverage* m_beverage
    + MochaDecorator(Beverage* beverage):m_beverage(beverage){}
    + double cost()
    + string getDescription()
}


}
@enduml